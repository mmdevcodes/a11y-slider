{"version":3,"sources":["webpack:///./node_modules/refractor/lang/jsx.js"],"names":["jsx","Prism","javascript","util","clone","languages","extend","tag","pattern","inside","insertBefore","spread","punctuation","script","alias","rest","stringifyToken","token","content","map","join","hooks","add","env","language","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","Token","module","exports","displayName","aliases"],"mappings":"8FAMA,SAASA,EAAIC,IAGX,SAAWA,GACT,IAAIC,EAAaD,EAAME,KAAKC,MAAMH,EAAMI,UAAUH,YAClDD,EAAMI,UAAUL,IAAMC,EAAMI,UAAUC,OAAO,SAAUJ,GACvDD,EAAMI,UAAUL,IAAIO,IAAIC,QAAU,4LAClCP,EAAMI,UAAUL,IAAIO,IAAIE,OAAY,IAAED,QAAU,kBAChDP,EAAMI,UAAUL,IAAIO,IAAIE,OAAO,cAAcD,QAAU,yDACvDP,EAAMI,UAAUL,IAAIO,IAAIE,OAAY,IAAEA,OAAO,cAAgB,4BAC7DR,EAAMI,UAAUK,aAAa,SAAU,YAAa,CAClDC,OAAQ,CACNH,QAAS,6CACTC,OAAQ,CACNG,YAAa,cACb,aAAc,SAGjBX,EAAMI,UAAUL,IAAIO,KACvBN,EAAMI,UAAUK,aAAa,SAAU,aAAc,CACnDG,OAAQ,CAENL,QAAS,4CACTC,OAAQ,CACN,qBAAsB,CACpBD,QAAS,UACTM,MAAO,eAETC,KAAMd,EAAMI,UAAUL,KAExBc,MAAO,wBAERb,EAAMI,UAAUL,IAAIO,KAEvB,IAAIS,EAAiB,SAASA,EAAeC,GAC3C,OAAKA,EAIgB,iBAAVA,EACFA,EAGoB,iBAAlBA,EAAMC,QACRD,EAAMC,QAGRD,EAAMC,QAAQC,IAAIH,GAAgBI,KAAK,IAXrC,IA8EXnB,EAAMoB,MAAMC,IAAI,kBAAkB,SAAUC,GACrB,QAAjBA,EAAIC,UAAuC,QAAjBD,EAAIC,UAjEnB,SAASC,EAAWC,GAGnC,IAFA,IAAIC,EAAa,GAERC,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IAAK,CACtC,IAAIX,EAAQS,EAAOE,GACfE,GAAiB,EAgCrB,GA9BqB,iBAAVb,IACU,QAAfA,EAAMc,MAAkBd,EAAMC,QAAQ,IAAgC,QAA1BD,EAAMC,QAAQ,GAAGa,KAEnB,OAAxCd,EAAMC,QAAQ,GAAGA,QAAQ,GAAGA,QAE1BS,EAAWE,OAAS,GAAKF,EAAWA,EAAWE,OAAS,GAAGG,UAAYhB,EAAeC,EAAMC,QAAQ,GAAGA,QAAQ,KAEjHS,EAAWM,MAG2C,OAApDhB,EAAMC,QAAQD,EAAMC,QAAQW,OAAS,GAAGX,SAG1CS,EAAWO,KAAK,CACdF,QAAShB,EAAeC,EAAMC,QAAQ,GAAGA,QAAQ,IACjDiB,aAAc,IAIXR,EAAWE,OAAS,GAAoB,gBAAfZ,EAAMc,MAA4C,MAAlBd,EAAMC,QAExES,EAAWA,EAAWE,OAAS,GAAGM,eACzBR,EAAWE,OAAS,GAAKF,EAAWA,EAAWE,OAAS,GAAGM,aAAe,GAAoB,gBAAflB,EAAMc,MAA4C,MAAlBd,EAAMC,QAE9HS,EAAWA,EAAWE,OAAS,GAAGM,eAElCL,GAAiB,IAIjBA,GAAmC,iBAAVb,IACvBU,EAAWE,OAAS,GAAwD,IAAnDF,EAAWA,EAAWE,OAAS,GAAGM,aAAoB,CAGjF,IAAIC,EAAYpB,EAAeC,GAE3BW,EAAIF,EAAOG,OAAS,IAA+B,iBAAlBH,EAAOE,EAAI,IAA0C,eAAvBF,EAAOE,EAAI,GAAGG,QAC/EK,GAAapB,EAAeU,EAAOE,EAAI,IACvCF,EAAOW,OAAOT,EAAI,EAAG,IAGnBA,EAAI,IAA+B,iBAAlBF,EAAOE,EAAI,IAA0C,eAAvBF,EAAOE,EAAI,GAAGG,QAC/DK,EAAYpB,EAAeU,EAAOE,EAAI,IAAMQ,EAC5CV,EAAOW,OAAOT,EAAI,EAAG,GACrBA,KAGFF,EAAOE,GAAK,IAAI3B,EAAMqC,MAAM,aAAcF,EAAW,KAAMA,GAI3DnB,EAAMC,SAAoC,iBAAlBD,EAAMC,SAChCO,EAAWR,EAAMC,UAUrBO,CAAWF,EAAIG,WApHnB,CAsHGzB,GA7HLsC,EAAOC,QAAUxC,EACjBA,EAAIyC,YAAc,MAClBzC,EAAI0C,QAAU","file":"react-syntax-highlighter_languages_refractor_jsx-8b9a8eff661545b8c137.js","sourcesContent":["'use strict';\n\nmodule.exports = jsx;\njsx.displayName = 'jsx';\njsx.aliases = [];\n\nfunction jsx(Prism) {\n  ;\n\n  (function (Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript);\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript);\n    Prism.languages.jsx.tag.pattern = /<\\/?(?:[\\w.:-]+\\s*(?:\\s+(?:[\\w.:-]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s{'\">=]+|\\{(?:\\{(?:\\{[^}]*\\}|[^{}])*\\}|[^{}])+\\}))?|\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}))*\\s*\\/?)?>/i;\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i;\n    Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s'\">]+)/i;\n    Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n    Prism.languages.insertBefore('inside', 'attr-name', {\n      spread: {\n        pattern: /\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}/,\n        inside: {\n          punctuation: /\\.{3}|[{}.]/,\n          'attr-value': /\\w+/\n        }\n      }\n    }, Prism.languages.jsx.tag);\n    Prism.languages.insertBefore('inside', 'attr-value', {\n      script: {\n        // Allow for two levels of nesting\n        pattern: /=(\\{(?:\\{(?:\\{[^}]*\\}|[^}])*\\}|[^}])+\\})/i,\n        inside: {\n          'script-punctuation': {\n            pattern: /^=(?={)/,\n            alias: 'punctuation'\n          },\n          rest: Prism.languages.jsx\n        },\n        alias: 'language-javascript'\n      }\n    }, Prism.languages.jsx.tag); // The following will handle plain text inside tags\n\n    var stringifyToken = function stringifyToken(token) {\n      if (!token) {\n        return '';\n      }\n\n      if (typeof token === 'string') {\n        return token;\n      }\n\n      if (typeof token.content === 'string') {\n        return token.content;\n      }\n\n      return token.content.map(stringifyToken).join('');\n    };\n\n    var walkTokens = function walkTokens(tokens) {\n      var openedTags = [];\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        var notTagNorBrace = false;\n\n        if (typeof token !== 'string') {\n          if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n                // Pop matching opening tag\n                openedTags.pop();\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {// Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                });\n              }\n            }\n          } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {\n            // Here we might have entered a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces++;\n          } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n            // Here we might have left a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces--;\n          } else {\n            notTagNorBrace = true;\n          }\n        }\n\n        if (notTagNorBrace || typeof token === 'string') {\n          if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n            // Here we are inside a tag, and not inside a JSX context.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token); // And merge text with adjacent text\n\n            if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n              plainText += stringifyToken(tokens[i + 1]);\n              tokens.splice(i + 1, 1);\n            }\n\n            if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText;\n              tokens.splice(i - 1, 1);\n              i--;\n            }\n\n            tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n          }\n        }\n\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content);\n        }\n      }\n    };\n\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\n        return;\n      }\n\n      walkTokens(env.tokens);\n    });\n  })(Prism);\n}"],"sourceRoot":""}